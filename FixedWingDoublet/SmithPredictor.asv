function [Time_pred, Y_pred] = ...
    SmithPredictor(sysDT, Time, Measurement, Input, VEq, thetaEq, deEq, ICdel, ICund, in_delDT, out_delDT, e1, e2, e3, Ts)

% SmithPredictor.m
%
% Smith Predictor simulation

%%%INPUTS%%%
% sysCT: The continuous time (CT) system of the UAV
% Klqr: The LQR controller gain
% Sim.t_vec: Time_vector of the simulation [s]
% x_vec0: Initial states for the simulation to start. The UAV is assumed to
% start from its steady-states
% ref_vec: The actual reference vector without any delay
% in_delDT: The value of the delay in the outgoing signal from the
% groundstation to the UAV, seconds
% out_delDT: The value of the delay in the incoming signal from the UAV to
% the groundstation, seconds
% uSS: Steady state input values. As the simulation starts from
% steady-state these are also the initial values of the input thrusts and
% torques
% isLinear: Boolean. Should the linear or nonlinear model be used to
% generate the actual output

%%%OUTPUTS%%%
% Y_pred: The output of the Smith's Predictor

%%% EQUATIONS OF MOTION %%%
%Steady-state values
%Obtained by solving Vss^2 = uss^2+vss^2+wss^2 and alpha_ss = arctan(wss/uss)
uss = VEq*cos(thetaEq); wss = VEq*sin(thetaEq); vss = 0;
%Others are 0
phiss = 0; thetass = thetaEq; psiss = 0; pss = 0; qss = 0; rss = 0;

%%% EOMS IN DISCRETE TIME %%%
%Initial states
Xss = [phiss; thetass; psiss; uss;vss;wss; pss;qss;rss];
Shat(:, 1) = ICdel(1:3); deltaXdel(:,1) = ICdel(4:12) - Xss;

deltaU = Input - [0;deEq;0];

i = in_delDT + out_delDT - 1;

predictor_index = 1; %Equivalent to l=k-d2; so the initial conditions start at l=k-d2 which is different from ode45 ICs

for k = 1:length(Time)-1
    if k - in_delDT - out_delDT - 1 > 0
        %Delayed states one-step propagation
        deltaXdel(:, predictor_index + 1) = sysDT.A * deltaXdel(:, predictor_index) + sysDT.B * deltaU(:, k - in_delDT - out_delDT - 1);
        %Delayed output, y_hat_del
        Y_hat_del(:, predictor_index) = eye(12) * [Shat(:, predictor_index); deltaXdel(:, predictor_index) + Xss];
        
        %Calculating the next step positions using nonlinear equations and
        %delayed states
        phi = deltaXdel(1, predictor_index) + Xss(1); theta = deltaXdel(2, predictor_index) + Xss(2); psi = deltaXdel(3, predictor_index) + Xss(3); 
        u = deltaXdel(4, predictor_index) + Xss(4); v = deltaXdel(5, predictor_index) + Xss(5); w = deltaXdel(6, predictor_index) + Xss(6);
        RIB = expm(psi*hat(e3))*expm(theta*hat(e2))*expm(phi*hat(e1));
        Shat(:, predictor_index + 1) = Shat(:, predictor_index) + RIB * [u; v; w] * Ts;

        S_prev = Shat(:, predictor_index + 1); RIB_prev = RIB; u_prev = u; v_prev = v; w_prev = w;
        deltaXhat_prev = deltaXdel(:, predictor_index + 1);
        for j = 0 : i
            deltaXhat_pred = sysDT.A * deltaXhat_prev + sysDT.B * deltaU(:, k - in_delDT - out_delDT + j);
            
            %Calculating the positions using nonlinear equations
            phi_pred = deltaXhat_pred(1)+Xss(1); theta_pred = deltaXhat_pred(2)+Xss(2); 
            psi_pred = deltaXhat_pred(3)+Xss(3); u_pred = deltaXhat_pred(4)+Xss(4);
            v_pred = deltaXhat_pred(5)+Xss(5); w_pred = deltaXhat_pred(6)+Xss(6);
            
            RIB_pred = expm(psi_pred*hat(e3))*expm(theta_pred*hat(e2))*expm(phi_pred*hat(e1));
            
            S_pred = S_prev + RIB_prev*[u_prev;v_prev;w_prev]*Ts;
            
            deltaXhat_prev = deltaXhat_pred; S_prev = S_pred; P_prev = P_pred; RIB_prev=RIB_pred; u_prev=u_pred; v_prev=v_pred; w_prev=w_pred; 
        end
        %Undelayed states one-step propagation
        deltaXund(:,predictor_index+1) = sysDT.A*deltaXund(:,predictor_index) + sysDT.B*deltaU(:, k);
        %Undelayed output, y_hat_und
        Y_hat_und(:,predictor_index) = eye(12)*[Sund(:, predictor_index); deltaXund(:,predictor_index)+Xss];
        
        %Calculating the next step positions using nonlinear equations and
        %delayed states
        phi_und = deltaXund(1,predictor_index+1) + Xss(1); theta_und = deltaXund(2,predictor_index+1) + Xss(2); psi_und = deltaXund(3,predictor_index+1) + Xss(3); 
        u_und = deltaXund(4,predictor_index+1) + Xss(4); v_und = deltaXund(5,predictor_index+1) + Xss(5); w_und = deltaXund(6,predictor_index+1) + Xss(6);
        RIB_und = expm(psi_und*hat(e3))*expm(theta_und*hat(e2))*expm(phi_und*hat(e1));
        Sund(:, predictor_index+1) = Sund(:,predictor_index) + RIB_und*[u_und;v_und;w_und]*Ts;
                
        %Calculate the predicted output
        Y_pred(:, predictor_index) = Measurement(:,k) + Y_hat_und(:,predictor_index) - Y_hat_del(:,predictor_index); %Measurement at k is already delayed
        Time_pred(predictor_index) = Time(k);
        predictor_index = predictor_index + 1;
    end
end


