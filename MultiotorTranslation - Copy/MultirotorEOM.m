function [fx, gx, dx_vecdtActual, dx_vecdtModel] = MultirotorEOM(Param)

% MultirotorEOM.m
%
% For deriving the dynamic EOMs of a multirotor aircraft adopted from
% Nazmus Sakib's dissertation. This script symbolically or numerically
% finds the EOMs based on Eqn. 3.4 in the dissertation. This EOM derivation
% includes aerodynamic forces, moments and gyroscopic moments. Terms can be
% omitted to make the kinematic and dynamic EOMs simpler. The function
% takes symbolic variables as inputs. The term "actual" here is used to 
% distinguish from the "modeled" EOMs. The "actual" EOM function is used 
% to obtain outputs for the simulation. The "modeled" EOMs are used to 
% predict the system dynamics. This demonstrates the effect of different 
% predictors when the model and the actual values are different. Here, the 
% "model" is intentionally made different (without having Aero/Gyro
% forces/moments) to see how different predictors perform

%%%INPUT%%%
% Param: Structure with fields containing mass and inertia properties,
% states, and system inputs. Param should be constructed with the
% following fields:
% Param.m: mass of the UAV, [kg]
% Param.I: 3x3 Moment of inertia matrix of the UAV, [kg-m^2]
% Param.states: The 12-states of the UAV arranged as: [x y z phi_r
% theta_r psi_r u v w p q r]
% Param.inputs: The 4-inputs of the UAV (force and moments)

%%%OUTPUT%%%
% dx_vecdtActual: The 12 nonlinear EOMs simulating the actual motion
% dx_vecdtModel: "Model" of the the "actual" 12 nonlinear EOMs of a UAV

% Basis vectors in 3D
e1 = [1;0;0]; e2 = [0;1;0]; e3 = [0;0;1];

Inertia = Param.I; m = Param.m; g = Param.g; rho = Param.rho; W = Param.W;

%State vectors
%Position vector of FB w.r.t. FI, [m]
s_vec = [Param.states(1); Param.states(2); Param.states(3)]; 
%Rotation of FB w.r.t. FI, [rad]
Theta_vec = [Param.states(4); Param.states(5); Param.states(6)];
%Velocity in FB, [m/s]
v_vec = [Param.states(7); Param.states(8); Param.states(9)]; 
%FB angular rates, rad/s
omega_vec = [Param.states(10); Param.states(11); ...
    Param.states(12)];

%Input forces and moments
u_T = Param.inputs(1); u_phi = Param.inputs(2); u_theta = Param.inputs(3);
u_psi = Param.inputs(4);

%Extracting individual states
x = s_vec(1); y = s_vec(2); z = s_vec(3); phi_r = Theta_vec(1);
theta_r = Theta_vec(2); psi_r = Theta_vec(3); u = v_vec(1); v = v_vec(2);
w = v_vec(3); p = omega_vec(1); q = omega_vec(2); r = omega_vec(3);

%Rotation matrix and attitude kinematic equations
RIB = expm(psi_r*skew_convert(e3))*expm(theta_r*skew_convert(e2))*...
    expm(phi_r*skew_convert(e1));
LIB = [1, sin(phi_r)*tan(theta_r), cos(phi_r)*tan(theta_r);
    0, cos(phi_r), -sin(phi_r);
    0, sin(phi_r)/cos(theta_r), cos(phi_r)/cos(theta_r)];

%sqrt(u^2+v^2+w^2) gives "div by 0" error around hover. So adding a small
%value "epsilon" to not have that error at hover
epsilon = .0000000000001;  
%Aerodynamic forces and moments, having a drag model for nows
F_aero = -.5*rho*sqrt(v_vec(1)^2 + v_vec(2)^2 + ...
    v_vec(3)^2 + epsilon)*[Param.aero(1)*v_vec(1); Param.aero(2)*v_vec(2); ...
    Param.aero(3)*v_vec(3)];
M_aero = 0;

%Propulsive forces and moments, these are generated by the inputs to the
%system
F_prop = u_T*e3; %Force along kb axis 
%Roll, pitch, yaw moments in ib, jb, kb 
M_prop = u_phi*e1 + u_theta*e2 + u_psi*e3; 

%Gravity and gyroscopic moment (Gyro forces assumed to be 0 for now)
F_gravity = RIB'*(m*g*e3);
M_gyro = 0;

% Sum of forces and moments
Force = F_gravity + F_aero + F_prop;
Moment = M_aero + M_prop + M_gyro;

% KINEMATIC EQUATIONS %%%
ds_vecdt = RIB*v_vec;
dTheta_vecdt = LIB*omega_vec;
 
% DYNAMIC EQUATIONS %%%
dv_vecdt = (1/m)*(cross(m*v_vec,omega_vec) + Force);
domega_vecdt = inv(Inertia)*(cross(Inertia*omega_vec,omega_vec) + Moment);

gx = jacobian([0; 0; 0; 0; 0; 0; 1/m*F_prop; inv(Inertia)*M_prop], ...
    [Param.inputs(1); Param.inputs(2); Param.inputs(3); Param.inputs(4)]);

%Form the 12 state EOM of the UAV
fx = [ds_vecdt; dTheta_vecdt; dv_vecdt; domega_vecdt];

%Form the 12 state EOM of the UAV
dx_vecdtActual = fx+gx*[Param.inputs(1); Param.inputs(2); Param.inputs(3); Param.inputs(4)];

%%
% Change the EOMs to generate a "slightly" different for the model
F_aero = 0; M_aero = 0; M_gyro = 0;

% Sum of forces and moments
Force = F_gravity + F_aero + F_prop;
Moment = M_aero + M_prop + M_gyro;

% KINEMATIC EQUATIONS %%%
ds_vecdt = RIB*v_vec;
dTheta_vecdt = LIB*omega_vec;
 
% DYNAMIC EQUATIONS %%%
dv_vecdt = (1/m)*(cross(m*v_vec,omega_vec) + Force);
domega_vecdt = inv(Inertia)*(cross(Inertia*omega_vec,omega_vec) + Moment);

%Form the 12 state EOM of the UAV
dx_vecdtModel = [ds_vecdt; dTheta_vecdt; dv_vecdt; domega_vecdt];
%%