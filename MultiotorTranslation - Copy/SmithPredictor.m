function [predicted_states_nonlinear, CLTF_DT, undelayed_states] = ...
    SmithPredictor(sysCT, Sim, available_states, Klqr)

% SmithPredictor.m
%
% Smith Predictor simulation

%%%INPUTS%%%
% sysCT: The continuous time (CT) system of the UAV
% Klqr: The LQR controller gain
% Sim.t_vec: Time_vector of the simulation [s]
% x_vec0: Initial states for the simulation to start. The UAV is assumed to
% start from its steady-states
% ref_vec: The actual reference vector without any delay
% in_delDT: The value of the delay in the outgoing signal from the
% groundstation to the UAV, seconds
% out_delDT: The value of the delay in the incoming signal from the UAV to
% the groundstation, seconds
% uSS: Steady state input values. As the simulation starts from
% steady-state these are also the initial values of the input thrusts and
% torques
% isLinear: Boolean. Should the linear or nonlinear model be used to
% generate the actual output

%%%OUTPUTS%%%
% predicted_states: The output of the Smith's Predictor
% u_actual: The input thrust and torque generated by the controller for the
% system

%Obtain the closed-loop transfer function (CLTF) with the LQR controller by
%constructing the controller block diagram. The CLTF is required to 
%simulate the Smith's predictor. 

%Specify the inputs to the system and the output
sysCT.InputName = {'u_T', 'u_phi', 'u_theta', 'u_psi'};
sysCT.OutputName = {'y'};
%Create the summing junction: error = reference - output, 12 elements
sum1 = sumblk('e = r - y', 12);
%Convert the LQR gain block to state-space form
LQRSS = ss(Klqr);
LQRSS.InputName = {'e'}; LQRSS.OutputName = {'u_T', 'u_phi', ...
    'u_theta', 'u_psi'};
%Complete the CLTF block diagram, 'r' is the input to the CLTF and 'y' is 
%its output
CLTF = connect(sysCT, LQRSS, sum1, 'r' , 'y');

CLTF.A = (sysCT.A-sysCT.B*Klqr);
CLTF.B = - (sysCT.A-sysCT.B*Klqr);
CLTF.C = sysCT.C;
CLTF.D = [];

%Convert it to Discrete Time (DT)
CLTF_DT = c2d(CLTF, Sim.Ts, 'zoh');

delay_horizon = Sim.in_delDT+Sim.out_delDT; 
undelayed_states(:,1) = Sim.initial_state;
delayed_states(:,1) = Sim.initial_state;
for i=2:length(Sim.t_vec)
    undelayed_states(:,i) = Sim.des_state(:,i) + CLTF_DT.A*undelayed_states(:,i-1)-CLTF_DT.A*Sim.des_state(:,i-1);
    if i>delay_horizon+1
        delayed_states(:,i) = Sim.des_state(:,i-delay_horizon) + CLTF_DT.A*delayed_states(:,i-1)-CLTF_DT.A*Sim.des_state(:,i-delay_horizon-1);
        %delayed_states(:,i) = Sim.des_state(:,i) + CLTF_DT.A*undelayed_states(:,i-1)-CLTF_DT.A*Sim.des_state(:,i-delay_horizon-1);
    else 
        delayed_states(:,i) = Sim.initial_state;
    end 
end
N_plot = 4;
plot (Sim.t_vec, Sim.des_state(N_plot,:), 'k-', Sim.t_vec, ...
    Sim.del_des_state(N_plot,:), 'k--', Sim.t_vec, undelayed_states(N_plot,:), ...
    'r-', Sim.t_vec, delayed_states(N_plot,:), 'r--')
title('SP')
xlabel('Time, t (s)')
ylabel('Roll, \phi (rad)')


%Predited states of the nonlinear delayed system 
predicted_states_nonlinear = available_states + ...
    (undelayed_states - delayed_states);