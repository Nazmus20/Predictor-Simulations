function [predicted_states_linear, predicted_states_nonlinear] = ...
    SmithPredictor(sysCT, t_vec, x_vec0, ref_vec, in_del, out_del, ...
    delayed_states_linear, delayed_states_nonlinear, Klqr)

% SmithPredictor.m
%
% Smith Predictor simulation

%%%INPUTS%%%
% sysCT: The continuous time (CT) system of the UAV
% Klqr: The LQR controller gain
% t_vec: Time_vector of the simulation, s
% x_vec0: Initial states for the simulation to start. The UAV is assumed to
% start from its steady-states
% ref_vec: The actual reference vector without any delay
% in_delDT: The value of the delay in the outgoing signal from the
% groundstation to the UAV, seconds
% out_delDT: The value of the delay in the incoming signal from the UAV to
% the groundstation, seconds
% uSS: Steady state input values. As the simulation starts from
% steady-state these are also the initial values of the input thrusts and
% torques
% isLinear: Boolean. Should the linear or nonlinear model be used to
% generate the actual output

%%%OUTPUTS%%%
% predicted_states: The output o fthe Smith's Predictor
% u_actual: The input thrust and torque generated by the controller for the
% system

%Obtain the closed-loop transfer function (CLTF) with the LQR controller by
%constructing the controller block diagram. The CLTF is required to 
%simulate the Smith's predictor. 

%Specify the inputs to the system and the output
sysCT.InputName = {'u_T', 'u_phi', 'u_theta', 'u_psi'};
sysCT.OutputName = {'y'};
%Create the summing junction: error = reference - output, 12 elements
sum1 = sumblk('e = r - y', 12);
%Convert the LQR gain block to state-space form
LQRSS = ss(Klqr);
LQRSS.InputName = {'e'}; LQRSS.OutputName = {'u_T', 'u_phi', ...
    'u_theta', 'u_psi'};
%Complete the CLTF block diagram, 'r' is the input to the CLTF and 'y' is 
%its output
CLTF = connect(sysCT, LQRSS, sum1, 'r' , 'y');

%Add outgoing delay to reference commands
del_ref_vec = addDelay(t_vec, ref_vec, out_del, x_vec0); 

%Start with worng states !!!!!!!!!!!!!!!!
wrong_states = zeros(12,1);
%Obtain the estimated output of Smith Predictor when there is delay 
states = lsim(CLTF, del_ref_vec, t_vec, wrong_states);

%Since the output is affected by another delay (incoming delay) add another
%delay, in_del, to the estimated states
delayed_states = addDelay(t_vec, states', in_del, wrong_states);

%{
for i=1:length(t_vec)
    if i <= in_delDT
        %Initial states are unchanged until delay time has passed
        delayed_states(i,:) = x_vec0'; 
    else
        delayed_states(i,:) = delayed_states1(i-in_delDT,:);
    end
end
%}

%Obtain the estimated output of Smith Predictor when there is no delay
undelayed_states = lsim(CLTF, ref_vec, t_vec, wrong_states);

%Since the output is affected by another delay (incoming delay) add another
%delay to it just like before
%actual_states_linear1 = lsim(CLTF, delayed_ref_vec, t_vec, x_vec0);
%actual_states_linear = addDelay(t_vec, actual_states_linear1', in_del, ...
%    x_vec0);
%{
for i=1:length(t_vec)
    if i <= in_delDT
        %Initial states are unchanged until delay time has passed
        actual_states_linear(i,:) = x_vec0'; 
    else
        actual_states_linear(i,:) = actual_states_linear1(i-in_delDT,:);
    end
end
%}
    
%Construct the Smith Predictor Predicted_output = Actual_output +
%(estimated undelayed output - estimated delayed output)

%Actual Output of the linear delayed system 
predicted_states_linear = delayed_states_linear + (undelayed_states' - ...
    delayed_states);

%Actual Output of the nonlinear delayed system 
predicted_states_nonlinear = delayed_states_nonlinear + ...
    (undelayed_states' - delayed_states);

%{
%Obtain the input history, For LQR u = -K*(x_delayed - ref_delayed). Here
%x_delayed and ref_delayed are the delayed only by the outgoing time delay.
%The incoming time delay only affects the communication from the UAV to the
%groundstation and as such not needed here.
for i=1:length(t_vec)
    u_actual(:,i) = uSS - Klqr*(actual_states_linear1(i,:)' - ...
        delayed_ref_vec(:,i));
end
    %}